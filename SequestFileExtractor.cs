using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading;
using PRISM.Logging;
using SequestResultsProcessor.Containers;

namespace SequestResultsProcessor
{

    // This class extracts peptide hit information from Sequest .out files and stores
    // it in synopsis (rootname_syn.txt) files that contain all the observed hits
    // (subject to an XCorr cutoff value), and first hits (rootname_fht.txt) files
    // that contain only the top-scoring hit from each result file (similar to the
    // now deprecated "summary.html" files generated by Sequest back in the day.
    //
    // -------------------------------------------------------------------------------
    // Originally written in Perl by Gary Kiebel
    // Ported to VB.NET by Ken Auberry for the Department of Energy (PNNL, Richland, WA)
    // Coding for this class began on 19 November 2004
    // -------------------------------------------------------------------------------
    //
    // Licensed under the Apache License, Version 2.0; you may not use this file except
    // in compliance with the License.  You may obtain a copy of the License at
    // http://www.apache.org/licenses/LICENSE-2.0

    // ReSharper disable once CheckNamespace
    public class SequestFileExtractor
    {

        // Const DEBUG_FLAG As Boolean = True

        private ConcatenatedOutFileProcessor _m_parser;

        private ConcatenatedOutFileProcessor m_parser
        {
            [MethodImpl(MethodImplOptions.Synchronized)]
            get => _m_parser;

            [MethodImpl(MethodImplOptions.Synchronized)]
            set
            {
                if (_m_parser != null)
                {
                    _m_parser.EndingTask -= TaskEndHandler;
                    _m_parser.ProgressReport -= ImportProgressHandler;
                }

                _m_parser = value;
                if (_m_parser != null)
                {
                    _m_parser.EndingTask += TaskEndHandler;
                    _m_parser.ProgressReport += ImportProgressHandler;
                }
            }
        }

        private readonly BackgroundWorker m_bkg = null;
        private static Regex mExtraProteinLineMatcher;
        private static Regex mHitLineMatcher;
        private static Regex mHitLineMatcherNoReference;
        private static Regex mTopProteinsMatcher;
        private static Regex mHeaderMassMatcher;
        private static Regex mDataBlockDelimiterMatcher;

        private enum eHitMatchType
        {
            NoMatch = 0,
            MatchWithProtein = 1,
            MatchWithoutProtein = 2
        }

        public SequestFileExtractor(StartupArguments StartupArgs)
        {
            m_parser = new ConcatenatedOutFileProcessor(StartupArgs);
            InitializeMatchers();
        }

        public SequestFileExtractor(StartupArguments StartupArgs, BackgroundWorker BackgroundWorker)
        {
            m_bkg = BackgroundWorker;
            m_parser = new ConcatenatedOutFileProcessor(StartupArgs, m_bkg);
            InitializeMatchers();
        }

        private void InitializeMatchers()
        {
            if (mExtraProteinLineMatcher is null)
            {
                mExtraProteinLineMatcher = new Regex(@"^\s+\d*\s+(?<reference>\S+)\s*(?<description>.*)", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);
            }

            // Notes:
            // The ID column is not always present; thus the use of * in (?<idblock>...)*
            // The sf column is present in Bioworks 3.3.x, which has SEQUEST v.28 (rev. 13)
            // Sf stands for "Final Score" and is a number meant to reflect the strength of the
            // Sequest hit on a scale of 0 to 1. The number is created by running
            // Sequest Utilities -> Spectra (DTA) Tools -> Final Score.
            // Numbers above 0.7 are considered "good"
            // The multiorf column is only present when a peptide is in multiple proteins; thus hte use of * in <?<multiorfblock>...)*
            if (mHitLineMatcher is null)
            {
                mHitLineMatcher = new Regex(@"^\s*(?<hitnum>\d+)\.\s+" + @"(?<rankxc>\d+)\s*\/\s*" + @"(?<ranksp>\d+)\s+" + @"(?<idblock>(?<id>\d+)\s+)*" + @"(?<mhmass>\d+\.\d+)\s+" + @"(?<delcn>\d+\.\d+)\s+" + @"(?<xcorr>\d+\.\d+)\s+" + @"(?<sp>\d+\.\d+)\s+" + @"(?<sfblock>(?<sf>[0-9.]+)\s+)*" + @"(?<obsions>\d+)\s*\/\s*" + @"(?<theoions>\d+)\s+" + @"(?<reference>\S+)\s+" + @"(?<multiorfblock>\+(?<multiorf>\d+)\s+)*" + @"(?<sequence>\S+)", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);
            }

            // The following is used to match lines that do not have any text in the Reference (protein name) column
            if (mHitLineMatcherNoReference is null)
            {
                mHitLineMatcherNoReference = new Regex(@"^\s*(?<hitnum>\d+)\.\s+" + @"(?<rankxc>\d+)\s*\/\s*" + @"(?<ranksp>\d+)\s+" + @"(?<idblock>(?<id>\d+)\s+)*" + @"(?<mhmass>\d+\.\d+)\s+" + @"(?<delcn>\d+\.\d+)\s+" + @"(?<xcorr>\d+\.\d+)\s+" + @"(?<sp>\d+\.\d+)\s+" + @"(?<sfblock>(?<sf>[0-9.]+)\s+)*" + @"(?<obsions>\d+)\s*\/\s*" + @"(?<theoions>\d+)\s+" + @"(?<sequence>\S+)", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);
            }

            if (mTopProteinsMatcher is null)
            {
                mTopProteinsMatcher = new Regex(@"^\s+\d+\.\s+\d*\s+(?<reference>\S+)\s+(?<description>.+)$", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);
            }

            if (mHeaderMassMatcher is null)
            {
                mHeaderMassMatcher = new Regex(@"mass\s+=\s+(?<headermass>\d+\.\d+)", RegexOptions.Compiled);
            }

            if (mDataBlockDelimiterMatcher is null)
            {
                mDataBlockDelimiterMatcher = new Regex(@"^\s+---\s+-{3,}", RegexOptions.Compiled);
            }
        }

        public void ProcessInputFile()
        {
            m_parser.ProcessInputFile();
        }

        public event ProgressReportEventHandler ProgressReport;

        public delegate void ProgressReportEventHandler(double fractionDone);

        public event StatusReportEventHandler StatusReport;

        public delegate void StatusReportEventHandler(string taskString);

        public event EndTaskEventHandler EndTask;

        public delegate void EndTaskEventHandler();

        protected void UpdateProgress(string currentTask, double fractionDone)
        {
            StatusReport?.Invoke(currentTask);
            ProgressReport?.Invoke(fractionDone);
        }

        protected void UpdateProgress(string currentTask, long currentFileCount, long totalFileCount)
        {
            clsUserProgressState state;
            double fractionDone;
            if (totalFileCount > 0L)
            {
                fractionDone = currentFileCount / (double)totalFileCount;
            }
            else
            {
                fractionDone = 0.0d;
            }

            if (m_bkg is object)
            {
                state = new clsUserProgressState(currentFileCount, totalFileCount, currentTask);
                m_bkg.ReportProgress(Conversions.ToInteger(fractionDone * 100.0d), state);
            }
            else
            {
                UpdateProgress(currentTask, fractionDone);
            }
        }

        protected void TaskEndHandler()
        {
            EndTask?.Invoke();
        }

        public void AbortProcessing()
        {
            if (m_parser is object)
            {
                m_parser.AbortProcessing();
            }
        }

        protected void ImportProgressHandler(string currentTask, long currentPosition, long totalSize)
        {
            UpdateProgress(currentTask, currentPosition, totalSize);
        }

        private class ConcatenatedOutFileProcessor
        {
            private StartupArguments m_StartupArguments;
            private string m_SourceFileFullPath;
            private ResultsStorage m_Results;
            private OutputIRRFile m_IRRDumper;
            private readonly BackgroundWorker m_bkg;
            private PRISM.Logging.FileLogger m_Logger;
            private bool m_StopProcessing;
            private const int RESULTS_DUMPING_INTERVAL = 200;

            #region  Progress Update Events
            internal event ProgressReportEventHandler ProgressReport;

            internal delegate void ProgressReportEventHandler(string currentTask, long currentPosition, long totalSize);

            internal event EndingTaskEventHandler EndingTask;

            internal delegate void EndingTaskEventHandler();

            private void EndTask()
            {
                EndingTask?.Invoke();
            }

            private void StartingNewTask(string taskName)
            {
                ProgressReport?.Invoke(taskName, 0L, 0L);
            }

            private void UpdateProgressCountingOuts(long currentFilePos, long totalFileSize)
            {
                string statusString = "Counting .out Files... ";
                ProgressReport?.Invoke(statusString, currentFilePos, totalFileSize);
                // If DEBUG_FLAG Then
                // Debug.WriteLine(DateTime.Now.ToString() + ", Status: '" + statusString + "' ; currentPos: " + currentFilePos.ToString() + " / " + totalFileSize.ToString() + "(" + (Math.Round(currentFilePos / totalFileSize, 1) * 100.0).ToString() + "%)")
                // End If
            }

            private void UpdateProgressExtracting(int currentOutFileCount, int totalOutFileCount)
            {
                string statusString = "Extracting from " + Path.GetFileNameWithoutExtension(m_SourceFileFullPath) + " (File " + currentOutFileCount.ToString() + " of " + totalOutFileCount.ToString() + ")";
                ProgressReport?.Invoke(statusString, currentOutFileCount, totalOutFileCount);
            }

            #endregion

            public ConcatenatedOutFileProcessor(StartupArguments ProcessSettings, BackgroundWorker backgroundWorker)
            {
                InitializeSettings(ProcessSettings);
                m_bkg = backgroundWorker;
            }

            public ConcatenatedOutFileProcessor(StartupArguments ProcessSettings)
            {
                InitializeSettings(ProcessSettings);
                m_bkg = null;
            }

            public void AbortProcessing()
            {
                m_StopProcessing = true;
            }

            private bool AdvanceReaderUntilMatch(StreamReader srInFile, Regex reMatcher, string dataLine, out string matchingLine)
            {
                if (reMatcher.IsMatch(dataLine))
                {
                    matchingLine = dataLine;
                    return true;
                }

                do
                {
                    if (!srInFile.EndOfStream)
                    {
                        string nextLine = srInFile.ReadLine();
                        bool matchFound = reMatcher.IsMatch(nextLine);
                        if (matchFound)
                        {
                            matchingLine = nextLine;
                            return true;
                        }
                    }
                    else
                    {
                        matchingLine = string.Empty;
                        return false;
                    }
                }
                while (true);
            }

            private void DumpCachedResults(string tmpFHTPath, string tmpSynPath, List<ResultsStorage.OutputRecordIndex> FHTOutputIndexList, List<ResultsStorage.OutputRecordIndex> SynOutputIndexList)
            {
                m_Results.ExportContents(ResultsStorage.OutputTypeList.FHT, m_StartupArguments.FHTXCorrThreshold, false, tmpFHTPath, FHTOutputIndexList);
                m_Results.ExportContents(ResultsStorage.OutputTypeList.Syn, m_StartupArguments.SynXCorrThreshold, m_StartupArguments.ExpandMultiORF, tmpSynPath, SynOutputIndexList);
                m_Results.ClearResults();
            }

            private void InitializeSettings(StartupArguments ProcessSettings)
            {
                m_StartupArguments = ProcessSettings;
                m_SourceFileFullPath = m_StartupArguments.InputFileFullPath;
                m_StartupArguments = ProcessSettings;
                m_Logger = new FileLogger(Path.Combine(m_StartupArguments.DestinationDirectory, Path.GetFileNameWithoutExtension(m_StartupArguments.LogFileName)));
            }

            /// <summary>
        /// Open a _out.txt file and extract the peptide info
        /// </summary>
        /// <remarks></remarks>
            public void ProcessInputFile()
            {
                bool makeIRRFile = false;
                string extractorVersion = Assembly.GetExecutingAssembly().GetName().Version.ToString();
                m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "------ Peptide File Extractor, " + Path.GetFileName(Assembly.GetExecutingAssembly().Location) + " v" + extractorVersion);
                ProgressReport?.Invoke("Initializing", 0L, 0L);
                m_Results = new ResultsStorage();
                var lstOutFilesProcessed = new SortedSet<string>();
                var FHTOutputIndexList = new List<ResultsStorage.OutputRecordIndex>();
                var SynOutputIndexList = new List<ResultsStorage.OutputRecordIndex>();
                var r_FileDelimiterMatcher = new Regex(@"^\s*[=]{5,}\s+\""(?<rootname>.+)\.(?<startscan>\d+)\.(?<endscan>\d+)\.(?<chargeblock>(?<chargestate>\d+)[^0-9]?(?<chargeextra>\S*))\.(?<filetype>.+)\""\s+[=]{5,}\s*$", RegexOptions.CultureInvariant | RegexOptions.Compiled | RegexOptions.IgnoreCase);
                if (m_StartupArguments.MakeIRRFile)
                {
                    m_IRRDumper = new OutputIRRFile(m_StartupArguments.RootFileName, m_StartupArguments.DestinationDirectory);
                    makeIRRFile = true;
                }

                var fi = new FileInfo(m_SourceFileFullPath);
                bool removeDupMultiProtRefs = m_StartupArguments.RemoveDuplicatedMultiProtRefs;
                string tmpFHTPath = Path.Combine(Path.GetDirectoryName(m_SourceFileFullPath), "Tmp_FHT.txt");
                string tmpSynPath = Path.Combine(Path.GetDirectoryName(m_SourceFileFullPath), "Tmp_Syn.txt");
                string tmpFHTProtPath = Path.Combine(Path.GetDirectoryName(m_SourceFileFullPath), "Tmp_FHT_Prot.txt");
                string tmpSynProtPath = Path.Combine(Path.GetDirectoryName(m_SourceFileFullPath), "Tmp_Syn_Prot.txt");
                var tmpFHTFI = new FileInfo(tmpFHTPath);
                var tmpSynFI = new FileInfo(tmpSynPath);
                var tmpFHTProtFI = new FileInfo(tmpFHTProtPath);
                var tmpSynProtFI = new FileInfo(tmpSynProtPath);
                if (tmpFHTFI.Exists)
                {
                    tmpFHTFI.Delete();
                }

                if (tmpSynFI.Exists)
                {
                    tmpSynFI.Delete();
                }

                if (tmpFHTProtFI.Exists)
                {
                    tmpFHTProtFI.Delete();
                }

                if (tmpSynProtFI.Exists)
                {
                    tmpSynProtFI.Delete();
                }

                if (!fi.Exists)
                {
                    m_Logger.LogMessage(BaseLogger.LogLevels.ERROR, "-------- ERROR: '" + m_SourceFileFullPath + "' apparently doesn't exist");
                    m_Logger.LogMessage(BaseLogger.LogLevels.ERROR, "-------- Exiting program ---------");
                    EndTask();
                    return;
                }

                int totalOutFileCount = CountOutFiles();
                int currentOutFileCount = 0;
                if (totalOutFileCount == 0)
                {
                    m_Logger.LogMessage(BaseLogger.LogLevels.ERROR, "-------- ERROR: '" + m_StartupArguments.InputFileName + "' contained no concatenated .out files");
                    m_Logger.LogMessage(BaseLogger.LogLevels.ERROR, "-------- Exiting program ---------");
                    EndTask();
                    return;
                }

                using (var srInFile = new StreamReader(new FileStream(fi.FullName, FileMode.Open, FileAccess.Read, FileShare.Read)))
                {
                    m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Processing '" + m_StartupArguments.InputFileName + "'");
                    while (!srInFile.EndOfStream)
                    {
                        string dataLine = srInFile.ReadLine();
                        string matchingLine = "";
                        bool outFileFound = AdvanceReaderUntilMatch(srInFile, r_FileDelimiterMatcher, dataLine, out matchingLine);
                        if (outFileFound)
                        {
                            // Check whether this .out file has already been processed
                            if (lstOutFilesProcessed.Contains(matchingLine))
                            {
                                // Skip this .out file
                                m_Logger.LogMessage(BaseLogger.LogLevels.WARN, "Skipping duplicate .out file: " + matchingLine.Trim('='));
                                Console.WriteLine("Warning, skipping duplicate .out file: " + matchingLine.Trim('='));
                                outFileFound = false;
                            }
                            else
                            {
                                lstOutFilesProcessed.Add(matchingLine);
                            }
                        }

                        if (outFileFound)
                        {
                            // Increment the currentOutFile counter
                            currentOutFileCount += 1;
                            if (currentOutFileCount % 1000 == 0)
                            {
                                m_Logger.LogMessage(BaseLogger.LogLevels.INFO, " ... " + currentOutFileCount.ToString().PadLeft(5) + " spectra processed");
                            }

                            ReadAndStoreOutFileResults(srInFile, matchingLine, r_FileDelimiterMatcher, makeIRRFile, removeDupMultiProtRefs);
                        }

                        if (currentOutFileCount % RESULTS_DUMPING_INTERVAL == 0 | currentOutFileCount >= totalOutFileCount)
                        {
                            if (m_bkg is object && m_bkg.CancellationPending)
                            {
                                EndTask();
                                return;
                            }

                            DumpCachedResults(tmpFHTPath, tmpSynPath, FHTOutputIndexList, SynOutputIndexList);
                            UpdateProgressExtracting(currentOutFileCount, totalOutFileCount);
                            GC.Collect();
                            GC.WaitForPendingFinalizers();
                            Thread.Sleep(100);
                        }
                    }
                }

                if (m_Results.Count > 0)
                {
                    DumpCachedResults(tmpFHTPath, tmpSynPath, FHTOutputIndexList, SynOutputIndexList);
                }

                m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Peak file '" + Path.GetFileName(tmpSynPath) + "' was generated");
                m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Peak file '" + Path.GetFileName(tmpFHTPath) + "' was generated");
                m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Peak file '" + Path.GetFileName(tmpSynPath) + "' contains " + SynOutputIndexList.Count.ToString().PadLeft(7) + " peptides " + "(XCorr Threshold was " + m_StartupArguments.SynXCorrThreshold.ToString() + " and subsequently filtered)");
                m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Peak file '" + Path.GetFileName(tmpFHTPath) + "' contains " + FHTOutputIndexList.Count.ToString().PadLeft(7) + " peptides " + "(XCorr Threshold was " + m_StartupArguments.FHTXCorrThreshold.ToString() + ")");

                // Keys in these dictionaries are XCorr threshold; values are the number of peptides with an XCorr over the threshold
                Dictionary<int, int> FHTSummaryResults;
                Dictionary<int, int> SynSummaryResults;
                if (!m_StopProcessing)
                {
                    StartingNewTask("Sorting results...");
                    m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Sorting peptides in Syn file");
                    SynSummaryResults = m_Results.SortPeptides(tmpSynPath, SynOutputIndexList, m_StartupArguments.SynopsisFileFullPath);
                    m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Sorting peptides in Fht file");
                    FHTSummaryResults = m_Results.SortPeptides(tmpFHTPath, FHTOutputIndexList, m_StartupArguments.FirstHitsFullPath);
                    m_Logger.LogMessage(BaseLogger.LogLevels.INFO, GetScoreSummary(SynSummaryResults, "all peptides"));
                    m_Logger.LogMessage(BaseLogger.LogLevels.INFO, GetScoreSummary(FHTSummaryResults, "first hits only"));
                    m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "Synopsis File   '" + Path.GetFileName(m_StartupArguments.SynopsisFileFullPath) + "' was generated");
                    m_Logger.LogMessage(BaseLogger.LogLevels.INFO, "First Hits File '" + Path.GetFileName(m_StartupArguments.FirstHitsFullPath) + "' was generated");
                }

                m_Logger = null;
                if (m_StartupArguments.MakeIRRFile)
                {
                    m_IRRDumper.CloseIRRWriter();
                }

                m_Results = null;
                EndTask();
            }

            private string GetScoreSummary(Dictionary<int, int> peptideCountsByXCorr, string statsDescription)
            {

                // "Scores (all peptides)     -> "
                // "Scores (first hits only)  -> "

                string msg = string.Format("Scores {0,-18} -> ", "(" + statsDescription + ")");
                var query = from item in peptideCountsByXCorr.Keys
                            orderby item
                            select item;
                foreach (var scoreThreshold in query)
                    msg += string.Format("{0,7} peptides above {1}, ", peptideCountsByXCorr[scoreThreshold], scoreThreshold);

                // Remove the trailing comma and space
                string trimmedMsg = msg.Trim();
                if (trimmedMsg.EndsWith(","))
                {
                    return trimmedMsg.Substring(0, trimmedMsg.Length - 1);
                }
                else
                {
                    return trimmedMsg;
                }
            }

            private int CountOutFiles()
            {
                var fi = new FileInfo(m_SourceFileFullPath);
                TextReader tr;
                string s;
                var outFileCount = default(int);
                var currPos = default(long);
                var lineCount = default(long);
                int lineEndCharCount = LineEndCharacterCount(fi);
                var r = new Regex("^===*", RegexOptions.Compiled);
                if (fi.Exists)
                {
                    tr = fi.OpenText();
                    s = tr.ReadLine();
                    while (s is object)
                    {
                        lineCount += 1L;
                        currPos += s.Length + lineEndCharCount;
                        if (r.IsMatch(s))
                            outFileCount += 1;
                        s = tr.ReadLine();
                        if (lineCount % 500L == 0L)
                        {
                            UpdateProgressCountingOuts(currPos, fi.Length);
                            if (m_StopProcessing)
                                break;
                        }
                    }

                    UpdateProgressCountingOuts(currPos, fi.Length);
                    tr.Close();
                    return outFileCount;
                }

                return default;
            }

            /// <summary>
        /// This function reads the input file one byte at a time, looking for the first occurence of Chr(10) or Chr(13) (aka vbCR or VBLF)
        /// When found, the next byte is examined
        /// If the next byte is also Chr(10) or Chr(13), then the line terminator is assumed to be 2 bytes; if not found, then it is assumed to be one byte
        /// </summary>
        /// <param name="fi"></param>
        /// <returns>1 if a one-byte line terminator; 2 if a two-byte line terminator</returns>
        /// <remarks></remarks>
            private int LineEndCharacterCount(FileInfo fi)
            {
                TextReader tr;
                int testcode;
                int testcode2;
                int endCount = 1;         // Initially assume a one-byte line terminator
                if (fi.Exists)
                {
                    tr = fi.OpenText();
                    for (long counter = 1L, loopTo = fi.Length; counter <= loopTo; counter++)
                    {
                        testcode = tr.Read();
                        if (testcode == 10 | testcode == 13)
                        {
                            testcode2 = tr.Read();
                            if (testcode2 == 10 | testcode2 == 13)
                            {
                                endCount = 2;
                                break;
                            }
                            else
                            {
                                endCount = 1;
                                break;
                            }
                        }
                    }

                    tr.Close();
                }

                return endCount;
            }

            private void ReadAndStoreOutFileResults(StreamReader srInFile, string fileHeaderLine, Regex fileDelimiterMatcher, bool makeIRRFile, bool removeDupMultiProtRefs)
            {
                int currentStartScan;
                int currentEndScan;
                int currentCS;
                double currentHeaderMass;

                // Extract File Header info
                var fileHeaderMatch = fileDelimiterMatcher.Match(fileHeaderLine);
                if (fileHeaderMatch.Success)
                {
                    currentStartScan = int.Parse(fileHeaderMatch.Groups["startscan"].Value);
                    currentEndScan = int.Parse(fileHeaderMatch.Groups["endscan"].Value);
                    currentCS = int.Parse(fileHeaderMatch.Groups["chargestate"].Value);
                }
                else
                {
                    currentStartScan = 0;
                    currentEndScan = 0;
                    currentCS = 0;
                }

                var tmpMultiProtRefs = new List<string>();
                string matchingLine = "";

                // Wait until we see the measured mass show up in the header
                bool blnFoundHeaderMass = AdvanceReaderUntilMatch(srInFile, mHeaderMassMatcher, "", out matchingLine);
                if (!blnFoundHeaderMass)
                    return;

                // grab the header mass value
                var headerMassMatch = mHeaderMassMatcher.Match(matchingLine);
                currentHeaderMass = Conversions.ToDouble(headerMassMatch.Groups["headermass"].Value);

                // Wait until we see the dashed line underneath the headings for the data block

                bool foundDataBlock = AdvanceReaderUntilMatch(srInFile, mDataBlockDelimiterMatcher, "", out matchingLine);
                if (!foundDataBlock || srInFile.EndOfStream)
                    return;

                // Read the first line of the data block
                string dataLine = srInFile.ReadLine();

                // As long as we keep seeing hit lines, keep grabbing them (also, allow one blank line)
                // (to separate that VERY last hit that creeps in)

                var eMatchType = eHitMatchType.MatchWithProtein;
                while (eMatchType != eHitMatchType.NoMatch && dataLine is object)
                {
                    var dataLineMatch = mHitLineMatcher.Match(dataLine);
                    if (dataLineMatch.Success)
                    {
                        eMatchType = eHitMatchType.MatchWithProtein;
                    }
                    else
                    {
                        dataLineMatch = mHitLineMatcherNoReference.Match(dataLine);
                        if (dataLineMatch.Success)
                        {
                            eMatchType = eHitMatchType.MatchWithoutProtein;
                        }
                        else
                        {
                            eMatchType = eHitMatchType.NoMatch;
                        }
                    }

                    if (eMatchType != eHitMatchType.NoMatch)
                    {
                        var currentPeptide = new PeptideHitEntry();
                        currentPeptide.HitNum = int.Parse(dataLineMatch.Groups["hitnum"].Value);
                        currentPeptide.MH = Math.Round(double.Parse(dataLineMatch.Groups["mhmass"].Value), 5);
                        currentPeptide.DelCn = double.Parse(dataLineMatch.Groups["delcn"].Value);
                        currentPeptide.XCorr = double.Parse(dataLineMatch.Groups["xcorr"].Value);
                        currentPeptide.Sp = double.Parse(dataLineMatch.Groups["sp"].Value);
                        if (eMatchType == eHitMatchType.MatchWithProtein)
                        {
                            currentPeptide.Reference = dataLineMatch.Groups["reference"].Value.ToString();
                            if (dataLineMatch.Groups["multiorf"].Length > 0)
                            {
                                currentPeptide.MultiProteinCount = int.Parse(dataLineMatch.Groups["multiorf"].Value);
                            }
                            else
                            {
                                currentPeptide.MultiProteinCount = 0;
                            }
                        }
                        else
                        {
                            currentPeptide.Reference = string.Empty;
                            currentPeptide.MultiProteinCount = 0;
                        }

                        currentPeptide.Peptide = dataLineMatch.Groups["sequence"].Value.ToString();
                        currentPeptide.RankSp = int.Parse(dataLineMatch.Groups["ranksp"].Value);
                        currentPeptide.RankXc = int.Parse(dataLineMatch.Groups["rankxc"].Value);
                        // If dataLineMatch.Groups("sf").Length > 0 Then
                        // .Sf = Double.Parse(dataLineMatch.Groups("sf").Value)
                        // Else
                        // .Sf = 0
                        // End If
                        currentPeptide.ObsIons = int.Parse(dataLineMatch.Groups["obsions"].Value);
                        currentPeptide.PossIons = int.Parse(dataLineMatch.Groups["theoions"].Value);
                        currentPeptide.XcRatio = 1d;
                        // '.PassFilt = 0
                        // '.MScore = 0
                        currentPeptide.StartScanNum = currentStartScan;
                        currentPeptide.EndScanNum = currentEndScan;
                        currentPeptide.ScanCount = currentEndScan - currentStartScan + 1;
                        currentPeptide.ChargeState = currentCS;
                        if (makeIRRFile)
                        {
                            m_IRRDumper.MakeIRREntry(currentStartScan, currentCS, currentPeptide.RankXc, currentPeptide.ObsIons, currentPeptide.PossIons);
                        }

                        // Read the next line
                        if (!srInFile.EndOfStream)
                        {
                            dataLine = srInFile.ReadLine();

                            // Look for multiprotein hit lines, but make sure to exclude those top scoring protein lines underneath them
                            do
                            {
                                var extraProteinLineMatch = mExtraProteinLineMatcher.Match(dataLine);
                                if (extraProteinLineMatch.Success && !mTopProteinsMatcher.IsMatch(dataLine))
                                {
                                    string tmpMultiProtRef = extraProteinLineMatch.Groups["reference"].Value.ToString();
                                    if (tmpMultiProtRefs.Contains(tmpMultiProtRef) && removeDupMultiProtRefs && !string.Equals(tmpMultiProtRef, currentPeptide.Reference, StringComparison.OrdinalIgnoreCase))

                                    {
                                    }
                                    // Skip this protein name
                                    else
                                    {
                                        // Store this protein name
                                        currentPeptide.AddMultiProteinRef(tmpMultiProtRef);
                                        tmpMultiProtRefs.Add(tmpMultiProtRef);
                                    }

                                    if (!srInFile.EndOfStream)
                                    {
                                        dataLine = srInFile.ReadLine();
                                    }
                                    else
                                    {
                                        dataLine = null;
                                        break;
                                    }
                                }
                                else
                                {
                                    break;
                                }
                            }
                            while (true);
                        }

                        currentPeptide.MultiProteinCount = tmpMultiProtRefs.Count;

                        // Store the results for this peptide
                        m_Results.AddPeptideResults(currentHeaderMass, currentPeptide);
                        tmpMultiProtRefs.Clear();
                    }
                }
            }
        }

        // Unused class
        // Private Class DTAFileInformation
        // Private m_Offsets As dtaFileOffsets
        // Private m_DTAFileIntensities As PeptideIntensities
        // Private m_dtaStream As FileStream
        // Private m_CurrScanNum As Integer
        // Private m_CurrCS As Integer

        // Public Sub New(ByVal dtaFilePath As String)
        // 'Scan the dta file for dta file boundaries
        // m_Offsets = New dtaFileOffsets
        // m_Offsets.LoadOffsetsFromDTAFile(dtaFilePath)
        // m_dtaStream = New FileStream(dtaFilePath, FileMode.Open)

        // End Sub

        // Public Function GetIntensityInfo( _
        // ByVal ScanNumber As Integer, _
        // ByVal ChargeState As Integer, _
        // ByVal PeptideMass As Double) As Double

        // If m_DTAFileIntensities Is Nothing OrElse _
        // ScanNumber <> m_CurrScanNum OrElse _
        // ChargeState <> m_CurrCS Then

        // m_DTAFileIntensities = GetDTAFileIntensities(ScanNumber, ChargeState)
        // m_CurrCS = ChargeState
        // m_CurrScanNum = ScanNumber
        // End If

        // Dim pepIntensity As Double

        // If m_DTAFileIntensities.ContainsKey(PeptideMass.ToString("0.0")) Then
        // pepIntensity = m_DTAFileIntensities.Intensity(PeptideMass.ToString("0.0"))
        // ElseIf m_DTAFileIntensities.ContainsKey(PeptideMass.ToString("0.00")) Then
        // pepIntensity = m_DTAFileIntensities.Intensity(PeptideMass.ToString("0.00"))
        // Else
        // pepIntensity = 0.0
        // End If

        // Return pepIntensity

        // End Function

        // Private Function GetDTAFileIntensities( _
        // ByVal ScanNumber As Integer, _
        // ByVal ChargeState As Integer) As PeptideIntensities

        // Dim fileOffset As Long = m_Offsets.GetOffset(ScanNumber, ChargeState)

        // Dim PI As New PeptideIntensities(fileOffset, m_dtaStream)

        // Return PI

        // End Function

        // Private Class dtaFileOffsets
        // Inherits Hashtable

        // Private m_FilePath As String

        // Public ReadOnly Property GetOffset(ByVal ScanNumber As Integer, ByVal ChargeState As Integer) As Long
        // Get
        // Return CLng(Me.Item(ScanNumber.ToString() + "." + ChargeState.ToString))
        // End Get
        // End Property

        // Sub AddOffset(ByVal StartScanNumber As Integer, ByVal EndScanNumber As Integer, ByVal ChargeState As Integer, ByVal StartOffset As Long)
        // Dim keyName As String = StartScanNumber.ToString() + "." + EndScanNumber.ToString() + "." + ChargeState.ToString
        // Me.Add(keyName, StartOffset)
        // End Sub

        // Function LoadOffsetsFromDTAFile(ByVal dtaFilePath As String) As Integer
        // Dim fi As System.IO.FileInfo = New FileInfo(dtaFilePath)
        // Dim tr As System.IO.TextReader
        // Dim s As String
        // Dim lineEndCharCount As Integer
        // Dim currPos As Long
        // Dim dtaStartPos As Long
        // Dim lastDTAstartPos As Long

        // Dim recordLength As Integer
        // Dim dtaCount As Integer
        // Dim fileLength As Long


        // Dim r As New Regex("\=+\s\""\S+\.(?<startscannum>\d+)\.(?<endscannum>\d+)\.(?<chargestate>\d+)\.\S+\""\s\=")
        // Dim lineMatch As New Regex("^===*")
        // Dim m As Match

        // If fi.Exists Then
        // lineEndCharCount = Me.LineEndCharacterCount(fi)
        // fileLength = fi.Length

        // tr = fi.OpenText()
        // s = tr.ReadLine

        // While Not s Is Nothing
        // currPos += s.Length + lineEndCharCount


        // If lineMatch.IsMatch(s) Then
        // dtaStartPos = currPos - s.Length - lineEndCharCount
        // recordLength = CInt(dtaStartPos - lastDTAstartPos - 1)
        // lastDTAstartPos = dtaStartPos
        // m = r.Match(s)
        // Me.AddOffset(CInt(m.Groups("startscannum").Value), _
        // CInt(m.Groups("endscannum").Value), _
        // CInt(m.Groups("chargestate").Value), dtaStartPos)
        // dtaCount += 1
        // End If
        // s = tr.ReadLine
        // End While

        // tr.Close()
        // tr = Nothing
        // fi = Nothing

        // End If

        // Return dtaCount

        // End Function

        // ''' <summary>
        // ''' This function reads the input file one byte at a time, looking for the first occurence of Chr(10) or Chr(13) (aka vbCR or VBLF)
        // ''' When found, the next byte is examined
        // ''' If the next byte is also Chr(10) or Chr(13), then the line terminator is assumed to be 2 bytes; if not found, then it is assumed to be one byte
        // ''' </summary>
        // ''' <param name="fi"></param>
        // ''' <returns>1 if a one-byte line terminator; 2 if a two-byte line terminator</returns>
        // ''' <remarks></remarks>
        // Private Function LineEndCharacterCount(ByVal fi As System.IO.FileInfo) As Integer
        // Dim tr As System.IO.TextReader
        // Dim testcode As Integer
        // Dim testcode2 As Integer
        // Dim counter As Long
        // Dim endCount As Integer = 1         ' Initially assume a one-byte line terminator

        // If (fi.Exists) Then
        // tr = fi.OpenText
        // For counter = 1 To fi.Length
        // testcode = tr.Read()
        // If testcode = 10 Or testcode = 13 Then
        // testcode2 = tr.Read()
        // If testcode2 = 10 Or testcode2 = 13 Then
        // endCount = 2
        // Exit For
        // Else
        // endCount = 1
        // Exit For
        // End If
        // End If
        // Next

        // tr.Close()
        // End If

        // tr = Nothing
        // Return endCount

        // End Function

        // Event dtaScanProgress(ByVal fractionDone As Double)

        // End Class

        // Private Class PeptideIntensities
        // Inherits Hashtable

        // Private m_FileStream As FileStream
        // Private m_ParentMass As Double

        // Sub New( _
        // ByVal fileOffset As Long, _
        // ByRef dtaFileStream As FileStream)

        // Me.m_FileStream = dtaFileStream

        // Me.AddIntensitiesFromDTA(fileOffset)
        // End Sub

        // Public ReadOnly Property Intensity(ByVal PeptideMass As String) As Double
        // Get
        // Return DirectCast(Me.Item(PeptideMass), Double)
        // End Get
        // End Property

        // Private Sub AddIntensitiesFromDTA(ByVal startOffset As Long)
        // Dim s As String

        // Dim tmpMass As String
        // Dim tmpIntensity As Double

        // Dim sr As New StreamReader(Me.m_FileStream)

        // sr.BaseStream.Seek(startOffset, SeekOrigin.Begin)
        // s = sr.ReadLine

        // If Regex.IsMatch(s, "^\s+") Then
        // Me.m_ParentMass = CDbl(Regex.Match(s, _
        // "^(?<parentmass>\d+\.\d+)").Groups("parentmass").Value)
        // End If

        // Dim RealLine As Regex = New Regex("^\s+")
        // Dim LineMatch As Regex = New Regex("^?<mass>\d+\.\d+)\s(?<intensity>\d+\.\d+)")
        // Dim m As Match

        // s = sr.ReadLine

        // While s.Length > 0
        // If RealLine.IsMatch(s) Then
        // m = LineMatch.Match(s)
        // tmpMass = m.Groups("mass").Value.ToString
        // tmpIntensity = CDbl(m.Groups("intensity").Value)

        // Me.AddPeptideIntensity(tmpMass, tmpIntensity)
        // s = sr.ReadLine
        // End If
        // End While

        // RealLine = Nothing
        // LineMatch = Nothing
        // End Sub

        // Private Sub AddPeptideIntensity(ByVal PeptideMass As String, ByVal Intensity As Double)
        // Me.Add(PeptideMass, Intensity)
        // End Sub

        // End Class

        // End Class

        public class StartupArguments
        {
            private string m_SourceDirectory;
            private string m_DestinationDirectory;
            private string m_InputFileName;
            private string m_SynopsisFileName;
            private string m_FirstHitsFileName;
            private string m_DTAFileName;
            private string m_LogFileName;
            private string m_RootFileName;

            // Xcorr Thresh
            // EFS Filter Thresh

            public StartupArguments(string SourceDirectory, string RootFileName)
            {
                m_SourceDirectory = SourceDirectory;
                m_RootFileName = RootFileName;
            }

            public StartupArguments()
            {
            }

            private bool CheckFileExists(string filePath)
            {
                var fi = new FileInfo(filePath);
                bool exists = fi.Exists;
                return exists;
            }

            public string SourceDirectory
            {
                get => m_SourceDirectory;

                set => m_SourceDirectory = value;
            }

            public string DestinationDirectory
            {
                get
                {
                    if (m_DestinationDirectory is null)
                    {
                        return m_SourceDirectory;
                    }
                    else
                    {
                        return m_DestinationDirectory;
                    }
                }

                set => m_DestinationDirectory = value;
            }

            public bool CatOutFileExists => CheckFileExists(InputFileFullPath);

            public bool CatDTAFileExists => CheckFileExists(DTAFileFullPath);

            public string RootFileName
            {
                get => m_RootFileName;

                set => m_RootFileName = value;
            }

            public string InputFileName
            {
                get
                {
                    if (m_InputFileName is null)
                    {
                        return m_RootFileName + "_out.txt";
                    }
                    else
                    {
                        return m_InputFileName;
                    }
                }

                set => m_InputFileName = value;
            }

            public string SynopsisFileName
            {
                get
                {
                    if (m_SynopsisFileName is null)
                    {
                        return m_RootFileName + "_syn.txt";
                    }
                    else
                    {
                        return m_SynopsisFileName;
                    }
                }

                set => m_SynopsisFileName = value;
            }

            public string FirstHitsFileName
            {
                get
                {
                    if (m_FirstHitsFileName is null)
                    {
                        return m_RootFileName + "_fht.txt";
                    }
                    else
                    {
                        return m_FirstHitsFileName;
                    }
                }

                set => m_FirstHitsFileName = value;
            }

            public string DTAFileName
            {
                get
                {
                    if (m_DTAFileName is null)
                    {
                        return m_RootFileName + "_dta.txt";
                    }
                    else
                    {
                        return m_DTAFileName;
                    }
                }

                set => m_DTAFileName = value;
            }

            public string LogFileName
            {
                get
                {
                    if (m_LogFileName is null)
                    {
                        return m_RootFileName + "_log.txt";
                    }
                    else
                    {
                        return m_LogFileName;
                    }
                }

                set => m_LogFileName = value;
            }

            public bool FilterEFS { get; set; } = false;
            public bool MakeIRRFile { get; set; } = false;
            public bool MakeNLIFile { get; set; } = false;
            public bool ExpandMultiORF { get; set; } = true;
            public bool HeaderInOutFile { get; set; } = false;
            public double FHTXCorrThreshold { get; set; } = 0.0d;
            public double FHTFilterScoreThreshold { get; set; } = 0.1d;
            public double SynXCorrThreshold { get; set; } = 1.5d;
            public double SynFilterScoreThreshold { get; set; } = 0.1d;
            public bool RemoveDuplicatedMultiProtRefs { get; set; } = false;

            public string InputFileFullPath => Path.Combine(DestinationDirectory, InputFileName);

            public string DTAFileFullPath => Path.Combine(DestinationDirectory, DTAFileName);

            public string FirstHitsFullPath => Path.Combine(DestinationDirectory, FirstHitsFileName);

            public string SynopsisFileFullPath => Path.Combine(DestinationDirectory, SynopsisFileName);

            public string LogFileFullPath => Path.Combine(DestinationDirectory, LogFileName);
        }

        // Unused class
        // Public Class ReverseComparer
        // Implements IComparer

        // Dim m_Comparer As IComparer

        // ' this constructor is called for the version that uses
        // ' the IComparable interface of individual items
        // Public Sub New()
        // End Sub

        // ' this constructor is called for the version that reverses
        // ' the result from another comparer
        // Public Sub New(ByVal comparer As IComparer)
        // m_Comparer = comparer
        // End Sub

        // Public Function Compare(ByVal x As Object, ByVal y As Object) As Integer _
        // Implements IComparer.Compare

        // If Not m_Comparer Is Nothing Then
        // ' use provided comparer, but reverse arguments to get the reverse effect
        // Return m_Comparer.Compare(y, x)
        // ElseIf Not x Is Nothing AndAlso TypeOf x Is IComparable Then
        // ' use x's IComparable interface, but negates result to get the reverse effect
        // Return -DirectCast(x, IComparable).CompareTo(y)
        // ElseIf Not y Is Nothing AndAlso TypeOf y Is IComparable Then
        // ' use y's IComparable interface - the result is such to obtain the reverse effect
        // Return DirectCast(y, IComparable).CompareTo(x)
        // Else
        // Throw New ArgumentException("Neither argument supports the IComparable interface")
        // End If
        // End Function
        // End Class

    }
}